https://explore-datascience.net/home/blog_single/3
H3: How Playing Games Inspires My Software Development
15 Sep 2019
Paragraph: Jacob Clarkson
Paragraph: 
Gaming has come a long way since the days it was seen as frivolous fun. Nowadays, it�s a massive industry that�s attracting serious scientific interest. Nevertheless, in my profession � software development � gaming still isn�t widely seen as something directly useful to my job. Reading�Justin Worthe�s excellent article�on how�programming�games inspired his software development made me realise that�playing�games has helped mine. Here�s how.

H2: Playing games gets me addicted to �Flow�
Paragraph: What is Flow?
Flow, in short, is a state of total concentration on the task at hand. It happens when my�skill�at a task is perfectly aligned with the�challenge�presented by that task. If I�m highly skilled and a task isn�t challenging enough, I become bored. If I�m a novice and the task is too difficult, I become anxious. When there�s a balance between my skill and the challenge, however, I enter that magical state where I can concentrate for hours, losing track of time and of my surroundings.

According to its progenitor,�Prof. Csikzentmihalyi�(that�s �chick-sent-mi-hai� to those of you whose Hungarian is as rusty as mine), we are at our very happiest when we are in a Flow state. Good game designers know this and try to make games that elicit a sense of Flow. That sense of total absorption is a core component of the experience and the enjoyment of playing games. Anyone who has ever sat down in the evening to play �just an hour� of their favorite game, only to be snuck up upon by the sunrise, knows this feeling. I�m looking at you,�Civilization!

Games allow me to maintain my state of Flow by giving me control over the�skill-challengebalance. If the game is getting boring, I can switch to a higher difficulty level. If the game is unenjoyable because I keep failing, I could lower the difficulty or try a different combination of weapons or spells. In a multiplayer game, I could identify the skill I�m lacking and practice it against automated bots, or maybe even overcome the obstacle with with a friend in co-operative mode.


How Flow helps me in software development

Flow while programming is no different to Flow while gaming. I�m sure that almost every programmer knows the magic of uninterrupted, hours-long stretches of coding. You know what you need to accomplish but it isn�t a boring or repetitive task. You�re familiar enough with the tools that you�re using so that you don�t have to think about them. You can just focus, not noticing things like temperature, hunger, or the passage of time. When you emerge, you feel as though you�ve been productive. You�re satisfied and happy. That�s Flow.

As a person who plays games, I�m frequently exposed to this state. I know what it feels like. This has helped me as a developer in two important ways: First, I know how pleasurable Flow is, so�I can actively seek to achieve and maintain it. I know that when I�m in Flow, I�m at my happiest and my most productive. This means that finding Flow is a win for both me and my team, so I know I need to find it. Second, when I realise I�m not in Flow,�I can try to figure out why it�s missing. I can do something about it � just as I would in a game:

If I get bored while working on a task, then maybe it is too easy. This usually happens when I�m doing something very repetitive. In this case, I ask myself: should I �turn up the difficulty� by automating this task? Developing an automation is a lot more challenging. It also happens to be very useful to my job: If I get the automation right, nobody, myself included, has to spend valuable time on that boring task any more.

If I�m stressed or anxious while doing a task, the task is too hard. This is the one I encounter more frequently in programming. It means that I should �lower the difficulty�. To do this, I ask myself:

Is there a �a different combination of weapons or spells� � a better method or a more suitable tool � that I should be using to accomplish this task?
Is there a specific skill that I need to �practice in single-player� � setting time aside to develop it � before I return to the task?
Does the task require me to go into �co-op mode with a friend� by opting for pair programming with someone more experienced?

Playing games teaches me useful behaviours

All games reward players for doing certain things. While the specific behaviours that get rewarded, as well as the rewards themselves, vary by game genre, there are a couple of common ones:
1. Curiosity

Open-world role-playing games such as�The Witcher�or�Skyrim�are particularly good at rewarding players for being curious and for exploring. In�The Witcher, for example, I�m lured far off the beaten path by question mark icons on the map, and receive various riches for reaching the marked locations.

These sorts of incentives are especially useful when I arrive in a new area. They encourage me to explore, find out where things are, and get the lay of the land. I also learn that the most obvious route is not always the best one. Rather than rushing straight to the finish line, I�m enticed into caves and up mountains. For who knows what I might find there! A bag of gold? A flaming sword? A rare mineral? Though sometimes, it turns out just to be some unpleasant, forgotten ruins!

The same applies to software development. Whether it�s a programming language I haven�t used before, getting put on a new project with an unfamiliar codebase, or getting access to a new server, exploring can be very helpful. In all of these cases, being curious and having a look around before I get started with the �main quest� helps me get a sense of�where�everything is and�why, which can only help me in the long run. I may even find things that others hadn�t noticed or were long forgotten about: an important �TODO� that was never done or a huge, mysterious, hidden ZIP file that really shouldn�t be included in those nightly backups. I�ll likely end up encountering a bunch of �unpleasant, forgotten ruins�, too � but that�s all part of �the game�.
TIP:�Keep in mind that in the real world, your �main quest� � your project � can�t just be left unfinished in your Steam library without consequence. Spend time exploring, but be sure to time-box it sensibly!

2. Persistence

The stakes in most games are never much higher than just having to wait for a few seconds to respawn at a previous checkpoint. I�m taught that my failures are temporary, and my successes are permanent.
I�m also taught that no task is insurmountable: if I ever get stuck, I just need to keep trying. I know that I�ll get a little bit better every time, until I can overcome whatever obstacle, or defeat whatever monster, has been put in front of me. And when I finally do, I feel that awesome sense of accomplishment: a much greater reward than whatever trinkets the slain monster drops in the game. The�Dark Souls�games, which are very challenging compared to most modern games, rely heavily on this reward: the feeling we get after overcoming a challenge. One way of looking at it is that people enjoy games like�Dark Souls�precisely because they are hard. I think the real reason is because the difficulty gives you the feeling that your victory is earned.

I don�t think I have ever won a single �boss fight� in any game on the first try. Rather, I�m repeatedly dashed against the rocks, maimed, and eviscerated. Each time, though, I get a little bit further and start to see the patterns in the monster�s behaviour, until I�m finally able to get the upper hand. This thought pattern is useful for my job, because at some point in my programming career, I will encounter bugs of �boss-fight� proportions. The strategy and attitude required to squash them is the same: try, try again, getting a little closer each time.
TIP: When you hit a hard problem, think of it as a �boss fight� in a game and put yourself in that same mindset. Remember that a bit of time and effort is all that separates you from your solution. Don�t give up. Rather, when the going gets tough, motivate yourself by looking forward to your well-earned victory.

3. An Inclination Towards Teamwork

Multiplayer games orientate players towards working together. Sometimes this is explicit: In�Heroes of the Storm, for example, you earn more experience for the same outcomes when you are playing with friends than when you are playing alone. More importantly, games teach me that there are implicit rewards to teamwork. Chief among them is an increased chance of success. The more effort I put into working together � identifying goals, deciding who should be doing what, allocating resources, and communicating � the greater this chance of success becomes.
In�DOTA�and related games, the strengths and weaknesses of each player on the team dictate not only what character they should play as, but how they should spend their time and individual resources during the course of a game. Each player has an individual goal: the �tank�, a tough character, attempts to protect weaker characters; the �healer� focuses on keeping everyone else on the team alive; the �carry� focusses on destroying the enemy. These individual goals are aligned toward the ultimate goal of winning the game. Clear communication is essential for making these strategic decisions before a game begins. So are the myriad tactical decisions that occur during the game, such as coordinating a surprise attack.
TIP:�Often, teamwork in games falls apart because some of the roles are seen as less glamorous than others � everybody wants to play as the �carry�! The same thing can happen in a software dev team. If everyone is �chief data scientist�, you probably won�t end up with a finished product, which is the ultimate goal. You should always keep in mind that the needs of the team should come before the needs of our egos.

Playing games teaches me how to grasp abstract systems

The primary purpose of playing games is to have fun. But before I can really start having fun, I have to learn how to play the game. Every time I pick up a new game, I want to learn how to play it as quickly as possible so that I can really get into the meat of it. This always involves learning how to navigate a UI, learning some set of controls, and some set of rules. Every video game is a complex, abstract system with which I must familiarise myself before I can enjoy it.

Sometimes this is a very simple task. In�Super Hexagon, for example, you only use two buttons to not crash into things. More often, there is�a lot�more to come to grips with. In�Elite: Dangerous, you begin the game sitting in a spaceship with basically no instructions or objectives. Looking directly ahead, there are about 9 components to the Heads-Up Display, showing you about 30 different pieces of information. On the left, a navigation panel with five screens of more information, and on the right, a systems panel with 5 screens of more information and controls. That is a lot to take in, especially while trying to figure out how to maneuver a 25-ton vehicle with six degrees of freedom! Good luck � and try not to hit the sides of the space station on your way out!

Playing games means that I�m putting myself in situations similar to this fairly regularly. If these are the sort of mental gymnastics I do for fun in my free time, then familiarising myself with a new codebase suddenly seems a lot less hard. The codebase doesn�t even come with the guy over there in a bigger spaceship bristling with lasers, who wants to take whatever is in my cargo hold!
A codebase and the tools I use to interact with it, in other words, are also a complex, abstract system: a bunch of controls, views, and interlinked systems and subsystems governed by some set of rules. The quicker I can grasp such a system, the sooner I can be effective within it. Games let me practice this skill in wonderfully unsafe and threatening environments.

Paragraph: 
Flow, in short, is a state of total concentration on the task at hand. It happens when my�skill�at a task is perfectly aligned with the�challenge�presented by that task. If I�m highly skilled and a task isn�t challenging enough, I become bored. If I�m a novice and the task is too difficult, I become anxious. When there�s a balance between my skill and the challenge, however, I enter that magical state where I can concentrate for hours, losing track of time and of my surroundings.

According to its progenitor,�Prof. Csikzentmihalyi�(that�s �chick-sent-mi-hai� to those of you whose Hungarian is as rusty as mine), we are at our very happiest when we are in a Flow state. Good game designers know this and try to make games that elicit a sense of Flow. That sense of total absorption is a core component of the experience and the enjoyment of playing games. Anyone who has ever sat down in the evening to play �just an hour� of their favorite game, only to be snuck up upon by the sunrise, knows this feeling. I�m looking at you,�Civilization!

Games allow me to maintain my state of Flow by giving me control over the�skill-challengebalance. If the game is getting boring, I can switch to a higher difficulty level. If the game is unenjoyable because I keep failing, I could lower the difficulty or try a different combination of weapons or spells. In a multiplayer game, I could identify the skill I�m lacking and practice it against automated bots, or maybe even overcome the obstacle with with a friend in co-operative mode.


How Flow helps me in software development

Flow while programming is no different to Flow while gaming. I�m sure that almost every programmer knows the magic of uninterrupted, hours-long stretches of coding. You know what you need to accomplish but it isn�t a boring or repetitive task. You�re familiar enough with the tools that you�re using so that you don�t have to think about them. You can just focus, not noticing things like temperature, hunger, or the passage of time. When you emerge, you feel as though you�ve been productive. You�re satisfied and happy. That�s Flow.

As a person who plays games, I�m frequently exposed to this state. I know what it feels like. This has helped me as a developer in two important ways: First, I know how pleasurable Flow is, so�I can actively seek to achieve and maintain it. I know that when I�m in Flow, I�m at my happiest and my most productive. This means that finding Flow is a win for both me and my team, so I know I need to find it. Second, when I realise I�m not in Flow,�I can try to figure out why it�s missing. I can do something about it � just as I would in a game:

If I get bored while working on a task, then maybe it is too easy. This usually happens when I�m doing something very repetitive. In this case, I ask myself: should I �turn up the difficulty� by automating this task? Developing an automation is a lot more challenging. It also happens to be very useful to my job: If I get the automation right, nobody, myself included, has to spend valuable time on that boring task any more.

If I�m stressed or anxious while doing a task, the task is too hard. This is the one I encounter more frequently in programming. It means that I should �lower the difficulty�. To do this, I ask myself:

Is there a �a different combination of weapons or spells� � a better method or a more suitable tool � that I should be using to accomplish this task?
Is there a specific skill that I need to �practice in single-player� � setting time aside to develop it � before I return to the task?
Does the task require me to go into �co-op mode with a friend� by opting for pair programming with someone more experienced?

Playing games teaches me useful behaviours

All games reward players for doing certain things. While the specific behaviours that get rewarded, as well as the rewards themselves, vary by game genre, there are a couple of common ones:
1. Curiosity

Open-world role-playing games such as�The Witcher�or�Skyrim�are particularly good at rewarding players for being curious and for exploring. In�The Witcher, for example, I�m lured far off the beaten path by question mark icons on the map, and receive various riches for reaching the marked locations.

These sorts of incentives are especially useful when I arrive in a new area. They encourage me to explore, find out where things are, and get the lay of the land. I also learn that the most obvious route is not always the best one. Rather than rushing straight to the finish line, I�m enticed into caves and up mountains. For who knows what I might find there! A bag of gold? A flaming sword? A rare mineral? Though sometimes, it turns out just to be some unpleasant, forgotten ruins!

The same applies to software development. Whether it�s a programming language I haven�t used before, getting put on a new project with an unfamiliar codebase, or getting access to a new server, exploring can be very helpful. In all of these cases, being curious and having a look around before I get started with the �main quest� helps me get a sense of�where�everything is and�why, which can only help me in the long run. I may even find things that others hadn�t noticed or were long forgotten about: an important �TODO� that was never done or a huge, mysterious, hidden ZIP file that really shouldn�t be included in those nightly backups. I�ll likely end up encountering a bunch of �unpleasant, forgotten ruins�, too � but that�s all part of �the game�.
TIP:�Keep in mind that in the real world, your �main quest� � your project � can�t just be left unfinished in your Steam library without consequence. Spend time exploring, but be sure to time-box it sensibly!

2. Persistence

The stakes in most games are never much higher than just having to wait for a few seconds to respawn at a previous checkpoint. I�m taught that my failures are temporary, and my successes are permanent.
I�m also taught that no task is insurmountable: if I ever get stuck, I just need to keep trying. I know that I�ll get a little bit better every time, until I can overcome whatever obstacle, or defeat whatever monster, has been put in front of me. And when I finally do, I feel that awesome sense of accomplishment: a much greater reward than whatever trinkets the slain monster drops in the game. The�Dark Souls�games, which are very challenging compared to most modern games, rely heavily on this reward: the feeling we get after overcoming a challenge. One way of looking at it is that people enjoy games like�Dark Souls�precisely because they are hard. I think the real reason is because the difficulty gives you the feeling that your victory is earned.

I don�t think I have ever won a single �boss fight� in any game on the first try. Rather, I�m repeatedly dashed against the rocks, maimed, and eviscerated. Each time, though, I get a little bit further and start to see the patterns in the monster�s behaviour, until I�m finally able to get the upper hand. This thought pattern is useful for my job, because at some point in my programming career, I will encounter bugs of �boss-fight� proportions. The strategy and attitude required to squash them is the same: try, try again, getting a little closer each time.
TIP: When you hit a hard problem, think of it as a �boss fight� in a game and put yourself in that same mindset. Remember that a bit of time and effort is all that separates you from your solution. Don�t give up. Rather, when the going gets tough, motivate yourself by looking forward to your well-earned victory.

3. An Inclination Towards Teamwork

Multiplayer games orientate players towards working together. Sometimes this is explicit: In�Heroes of the Storm, for example, you earn more experience for the same outcomes when you are playing with friends than when you are playing alone. More importantly, games teach me that there are implicit rewards to teamwork. Chief among them is an increased chance of success. The more effort I put into working together � identifying goals, deciding who should be doing what, allocating resources, and communicating � the greater this chance of success becomes.
In�DOTA�and related games, the strengths and weaknesses of each player on the team dictate not only what character they should play as, but how they should spend their time and individual resources during the course of a game. Each player has an individual goal: the �tank�, a tough character, attempts to protect weaker characters; the �healer� focuses on keeping everyone else on the team alive; the �carry� focusses on destroying the enemy. These individual goals are aligned toward the ultimate goal of winning the game. Clear communication is essential for making these strategic decisions before a game begins. So are the myriad tactical decisions that occur during the game, such as coordinating a surprise attack.
TIP:�Often, teamwork in games falls apart because some of the roles are seen as less glamorous than others � everybody wants to play as the �carry�! The same thing can happen in a software dev team. If everyone is �chief data scientist�, you probably won�t end up with a finished product, which is the ultimate goal. You should always keep in mind that the needs of the team should come before the needs of our egos.

Playing games teaches me how to grasp abstract systems

The primary purpose of playing games is to have fun. But before I can really start having fun, I have to learn how to play the game. Every time I pick up a new game, I want to learn how to play it as quickly as possible so that I can really get into the meat of it. This always involves learning how to navigate a UI, learning some set of controls, and some set of rules. Every video game is a complex, abstract system with which I must familiarise myself before I can enjoy it.

Sometimes this is a very simple task. In�Super Hexagon, for example, you only use two buttons to not crash into things. More often, there is�a lot�more to come to grips with. In�Elite: Dangerous, you begin the game sitting in a spaceship with basically no instructions or objectives. Looking directly ahead, there are about 9 components to the Heads-Up Display, showing you about 30 different pieces of information. On the left, a navigation panel with five screens of more information, and on the right, a systems panel with 5 screens of more information and controls. That is a lot to take in, especially while trying to figure out how to maneuver a 25-ton vehicle with six degrees of freedom! Good luck � and try not to hit the sides of the space station on your way out!

Playing games means that I�m putting myself in situations similar to this fairly regularly. If these are the sort of mental gymnastics I do for fun in my free time, then familiarising myself with a new codebase suddenly seems a lot less hard. The codebase doesn�t even come with the guy over there in a bigger spaceship bristling with lasers, who wants to take whatever is in my cargo hold!
A codebase and the tools I use to interact with it, in other words, are also a complex, abstract system: a bunch of controls, views, and interlinked systems and subsystems governed by some set of rules. The quicker I can grasp such a system, the sooner I can be effective within it. Games let me practice this skill in wonderfully unsafe and threatening environments.

Paragraph: Flow, in short, is a state of total concentration on the task at hand. It happens when my�skill�at a task is perfectly aligned with the�challenge�presented by that task. If I�m highly skilled and a task isn�t challenging enough, I become bored. If I�m a novice and the task is too difficult, I become anxious. When there�s a balance between my skill and the challenge, however, I enter that magical state where I can concentrate for hours, losing track of time and of my surroundings.
Paragraph: 
According to its progenitor,�Prof. Csikzentmihalyi�(that�s �chick-sent-mi-hai� to those of you whose Hungarian is as rusty as mine), we are at our very happiest when we are in a Flow state. Good game designers know this and try to make games that elicit a sense of Flow. That sense of total absorption is a core component of the experience and the enjoyment of playing games. Anyone who has ever sat down in the evening to play �just an hour� of their favorite game, only to be snuck up upon by the sunrise, knows this feeling. I�m looking at you,�Civilization!
Paragraph: 
Games allow me to maintain my state of Flow by giving me control over the�skill-challengebalance. If the game is getting boring, I can switch to a higher difficulty level. If the game is unenjoyable because I keep failing, I could lower the difficulty or try a different combination of weapons or spells. In a multiplayer game, I could identify the skill I�m lacking and practice it against automated bots, or maybe even overcome the obstacle with with a friend in co-operative mode.
Paragraph: 
Paragraph: How Flow helps me in software development
Paragraph: 
Flow while programming is no different to Flow while gaming. I�m sure that almost every programmer knows the magic of uninterrupted, hours-long stretches of coding. You know what you need to accomplish but it isn�t a boring or repetitive task. You�re familiar enough with the tools that you�re using so that you don�t have to think about them. You can just focus, not noticing things like temperature, hunger, or the passage of time. When you emerge, you feel as though you�ve been productive. You�re satisfied and happy. That�s Flow.
Paragraph: 
As a person who plays games, I�m frequently exposed to this state. I know what it feels like. This has helped me as a developer in two important ways: First, I know how pleasurable Flow is, so�I can actively seek to achieve and maintain it. I know that when I�m in Flow, I�m at my happiest and my most productive. This means that finding Flow is a win for both me and my team, so I know I need to find it. Second, when I realise I�m not in Flow,�I can try to figure out why it�s missing. I can do something about it � just as I would in a game:
Paragraph: 
If I get bored while working on a task, then maybe it is too easy. This usually happens when I�m doing something very repetitive. In this case, I ask myself: should I �turn up the difficulty� by automating this task? Developing an automation is a lot more challenging. It also happens to be very useful to my job: If I get the automation right, nobody, myself included, has to spend valuable time on that boring task any more.
Paragraph: 
If I�m stressed or anxious while doing a task, the task is too hard. This is the one I encounter more frequently in programming. It means that I should �lower the difficulty�. To do this, I ask myself:
Is there a �a different combination of weapons or spells� � a better method or a more suitable tool � that I should be using to accomplish this task?
Is there a specific skill that I need to �practice in single-player� � setting time aside to develop it � before I return to the task?
Does the task require me to go into �co-op mode with a friend� by opting for pair programming with someone more experienced?
H2: Playing games teaches me useful behaviours
Paragraph: 
All games reward players for doing certain things. While the specific behaviours that get rewarded, as well as the rewards themselves, vary by game genre, there are a couple of common ones:
Paragraph: 1. Curiosity
Paragraph: 
Open-world role-playing games such as�The Witcher�or�Skyrim�are particularly good at rewarding players for being curious and for exploring. In�The Witcher, for example, I�m lured far off the beaten path by question mark icons on the map, and receive various riches for reaching the marked locations.
Paragraph: 
These sorts of incentives are especially useful when I arrive in a new area. They encourage me to explore, find out where things are, and get the lay of the land. I also learn that the most obvious route is not always the best one. Rather than rushing straight to the finish line, I�m enticed into caves and up mountains. For who knows what I might find there! A bag of gold? A flaming sword? A rare mineral? Though sometimes, it turns out just to be some unpleasant, forgotten ruins!
Paragraph: 
The same applies to software development. Whether it�s a programming language I haven�t used before, getting put on a new project with an unfamiliar codebase, or getting access to a new server, exploring can be very helpful. In all of these cases, being curious and having a look around before I get started with the �main quest� helps me get a sense of�where�everything is and�why, which can only help me in the long run. I may even find things that others hadn�t noticed or were long forgotten about: an important �TODO� that was never done or a huge, mysterious, hidden ZIP file that really shouldn�t be included in those nightly backups. I�ll likely end up encountering a bunch of �unpleasant, forgotten ruins�, too � but that�s all part of �the game�.
Paragraph: 
Paragraph: 2. Persistence
Paragraph: 
The stakes in most games are never much higher than just having to wait for a few seconds to respawn at a previous checkpoint. I�m taught that my failures are temporary, and my successes are permanent.
I�m also taught that no task is insurmountable: if I ever get stuck, I just need to keep trying. I know that I�ll get a little bit better every time, until I can overcome whatever obstacle, or defeat whatever monster, has been put in front of me. And when I finally do, I feel that awesome sense of accomplishment: a much greater reward than whatever trinkets the slain monster drops in the game. The�Dark Souls�games, which are very challenging compared to most modern games, rely heavily on this reward: the feeling we get after overcoming a challenge. One way of looking at it is that people enjoy games like�Dark Souls�precisely because they are hard. I think the real reason is because the difficulty gives you the feeling that your victory is earned.
Paragraph: 
I don�t think I have ever won a single �boss fight� in any game on the first try. Rather, I�m repeatedly dashed against the rocks, maimed, and eviscerated. Each time, though, I get a little bit further and start to see the patterns in the monster�s behaviour, until I�m finally able to get the upper hand. This thought pattern is useful for my job, because at some point in my programming career, I will encounter bugs of �boss-fight� proportions. The strategy and attitude required to squash them is the same: try, try again, getting a little closer each time.
Paragraph: 
Paragraph: 3. An Inclination Towards Teamwork
Paragraph: 
Multiplayer games orientate players towards working together. Sometimes this is explicit: In�Heroes of the Storm, for example, you earn more experience for the same outcomes when you are playing with friends than when you are playing alone. More importantly, games teach me that there are implicit rewards to teamwork. Chief among them is an increased chance of success. The more effort I put into working together � identifying goals, deciding who should be doing what, allocating resources, and communicating � the greater this chance of success becomes.
Paragraph: In�DOTA�and related games, the strengths and weaknesses of each player on the team dictate not only what character they should play as, but how they should spend their time and individual resources during the course of a game. Each player has an individual goal: the �tank�, a tough character, attempts to protect weaker characters; the �healer� focuses on keeping everyone else on the team alive; the �carry� focusses on destroying the enemy. These individual goals are aligned toward the ultimate goal of winning the game. Clear communication is essential for making these strategic decisions before a game begins. So are the myriad tactical decisions that occur during the game, such as coordinating a surprise attack.
Paragraph: 
H2: Playing games teaches me how to grasp abstract systems
Paragraph: 
The primary purpose of playing games is to have fun. But before I can really start having fun, I have to learn how to play the game. Every time I pick up a new game, I want to learn how to play it as quickly as possible so that I can really get into the meat of it. This always involves learning how to navigate a UI, learning some set of controls, and some set of rules. Every video game is a complex, abstract system with which I must familiarise myself before I can enjoy it.
Paragraph: 
Sometimes this is a very simple task. In�Super Hexagon, for example, you only use two buttons to not crash into things. More often, there is�a lot�more to come to grips with. In�Elite: Dangerous, you begin the game sitting in a spaceship with basically no instructions or objectives. Looking directly ahead, there are about 9 components to the Heads-Up Display, showing you about 30 different pieces of information. On the left, a navigation panel with five screens of more information, and on the right, a systems panel with 5 screens of more information and controls. That is a lot to take in, especially while trying to figure out how to maneuver a 25-ton vehicle with six degrees of freedom! Good luck � and try not to hit the sides of the space station on your way out!
Paragraph: 
Playing games means that I�m putting myself in situations similar to this fairly regularly. If these are the sort of mental gymnastics I do for fun in my free time, then familiarising myself with a new codebase suddenly seems a lot less hard. The codebase doesn�t even come with the guy over there in a bigger spaceship bristling with lasers, who wants to take whatever is in my cargo hold!
Paragraph: A codebase and the tools I use to interact with it, in other words, are also a complex, abstract system: a bunch of controls, views, and interlinked systems and subsystems governed by some set of rules. The quicker I can grasp such a system, the sooner I can be effective within it. Games let me practice this skill in wonderfully unsafe and threatening environments.
H2: Latest Posts
15 Sep 2019
H3: How to Develop a Self-Driving Car in Under a Week.
Jason Webster

15 Sep 2019
H3: 4 Tips For Communicating Technical Ideas to a Non-tech Audience
Jason Webster

15 Sep 2019
H3: How Playing Games Inspires My Software Development.
Jacob Clarkson

H2: Lauch your career today 
and start doing Amazing Things
https://explore-datascience.net/home/blog_single/2
H3: 4 Tips For Communicating Technical Ideas to a Non-tech Audience
15 Sep 2019
Paragraph: Jason Webster
Paragraph: 
Communicating your ideas to a non-technical audience can be really tricky. Whether it�s presenting to your non-tech team lead, or communicating with text in an email or blog post, a confused audience is never ideal! In this article, I will share some tips that I use to communicate technical ideas in an understandable way when giving a presentation or writing blog posts, no matter the audience.
Paragraph: 
Over the past four or five years, I have presented my technical ideas to a variety of both technical and non-technical people. Along the way, I realised two important things about doing so:
It is very easy for a presenter to lose an audience, and
This is more often than not due to a lack of skill in the�presenter�- for example, not making it easy for an audience to understand what the talk is about.
Paragraph: 
When it comes to communicating ideas effectively, it�s your job as a presenter to make your talk enjoyable, to wow the crowd, and to help get across what you want to say in a clear and easy-to-follow way.
Paragraph: 
During this time, I�ve grown-out of shying away of giving presentations, and learned what it takes to give a successful presentation. Now,�I actually enjoy public speaking.
Paragraph: 
Here, I give some of the tips and tricks I�ve picked up along the way, with separate hacks for�giving a talk�or�writing a blog post.
Tailoring you technical talk�so that non-technical people can understand you.
Grabbing your audience�s attention from the start:�Technical content can be quite difficult to digest. Ensuring your audience follows along from the beginning almost guarantees a successful delivery of highly technical ideas.
Telling a story�to make your content as coherent as possible. I find that having an incoherent talk or article will lead to a lower audience.

Making your technical ideas relatable to �the everyday�: I like to highlight the �cool� factor of my work, and not worry too much about trying to prove I�m smart. Focus on understanding, rather than losing your audience to a cloud of technical jargon.

Making your technical ideas relatable to �the everyday�: I like to highlight the �cool� factor of my work, and not worry too much about trying to prove I�m smart. Focus on understanding, rather than losing your audience to a cloud of technical jargon.
H2: Tip 1: Tailor your talk
Paragraph: 
How do we tailor our talk around our audience? I�ve found that an effective way to present technical media is to tone down the technical content to an absolute minimum, and to not presume that my audience knows anything about the topic I am presenting. Surprisingly, I�ve found this works for technical audiences too, as it brings everyone up to speed without sacrificing your audience�s attention. It never hurts to slow down the talk, or blog post, with brief explanations of the deep technical points.
Paragraph: 
Giving a talk provides a unique opportunity to you when it comes to tailoring your talk. You�ll usually know who your audience is well ahead of time - you�ll be invited to a meetup, for example, and you�ll be able to ask the organizer what the �technical scope� of your audience is - in other words,�how technically minded they are.
Paragraph: 
Knowing the technical scope of my audience allows me to edit my slides and focus my talk in a direction that I feel the audience would be most comfortable with.
Paragraph: 
For example, I�ll remove as much technical jargon when talking to an average listener, and keep some of it in when my audience is more technical. Similarly, I�ll try to present some of the code and methodology involved in a talk when presenting to, say, software engineers. However, when talking to the public, I�ll instead focus more on what makes the talk �cool� - in other words, why they should care.
Paragraph: My advice here would be to:
Get an idea of who you�re presenting to ahead of time.
Use this information to make your talk as relatable as possible.
Be safe rather than sorry:�Don�t assume your audience knows too much. Try to make sure that everyone can follow along.
Paragraph: 
Paragraph: 
In the case of a blog post, I would think of my audience as being defined by the people that would want to know more from the title of my article. After all, that is typically the hook that most reading audiences see when scrolling through their favourite blogging website.
Paragraph: 
Knowing this, I�ve found that it really helps me to�tailor the title around the contents of my article or blog post. An easy hack I�ve learned is to get whoever fits �my audience� to read the title and guess what the article is about, or what they expect to get out of it. That gives me a good idea of whether my framing is too complex, or whether they�d actually click on it and read it.
As an example, here are three article titles:
�Technical talks for non-technical people�
�How I built a self driving car in under a week�, and
�Quick dive into centralising your data in Angular with ngrx/router-store.�
Paragraph: 
The first article is likely not going to deal with anything technical. The second probably has some technical content, and you�d probably want to know a bit of math in order to fully grasp what the article is talking about. The third, on the other hand, seems fairly technical, and will probably require an understanding of data structures and Angular before one is able to grasp the details of the content.
Paragraph: 
Where-as the first article has a pretty broad appeal, if you don�t know anything about Angular, would you even consider following the link to that last article? Probably not. Even if you wanted to learn about Angular as a beginner, you�d probably not start there either.
Paragraph: My advice here would be to:
Be consistent in your article. Write according to the audience that you think would be most interested in your article.
Following this,�structure your blog title around your article. Get a friend to sanity check the title, and see if they�d be able to guess the contents of your blog post.
H2: Tip 2: Grab your audience�s attention from the start
Paragraph: 
Technical content can often be very in-depth. This can provide a lot of opportunities for your audience to get lost�if�you aren�t careful. It�s important to make sure that your audience is paying attention from the very beginning, as this is often the part where you are explaining technical terms that may appear later on.
Paragraph: 
I�ve noticed that there tends to be a common theme in technical talks: The perception is often that, If the work you�ve done is technical, it should be presented in a very technical manner. However, I disagree.
Paragraph: 
I believe you should always present a technical talk with the�primary intention to entertain your audience, while at the same time educating them - something that is now becoming known as �edutainment�.
Paragraph: 
One common pitfall here is including a table of contents. This often comes before the technical communication stuff (such as reports, analysis, etc), but I have stopped using them altogether.
If your table of contents is anything like how everyone does them, it�s in bullet point form and lays out the structure of your talk. Personally, I always found myself talking about what my talk would be about (meta-talking!).
Paragraph: 
So, on the first or second slide, I would have already presented a wall of pretty uninteresting text that served little purpose, and I would have quickly lost my audience to their cellphones! At the early stages of my talk, where I would slowly introduce all the technical concepts of my topic, losing an audience meant they were lost for the remainder of the talk.
Paragraph: 
From this, I learned that every aspect of my talk should be�engaging and visually interesting�to my audience, while still making sure that my voice is the focus. My slides be visual aids in my story, and should be easily read at a glance. I converted any slide that had a lot of text into a pictorial story.
Paragraph: 
Another tactic that helped me was to beat my stage fright and excite myself about the talk. This helped me speak louder and more clearly, and being as energetic as possible helped keep people engaged and focused. I�d also use as much body language as possible to help keep even the more boring bits of the talk exciting to listen to.
Paragraph: To summarise, my advice here would be to:
Avoid losing your audience in the early stages of your talk, as this will likely mean that you�ve lost your audience for the entire talk.
Be as energetic as possible. This helps maintain my audience�s interest throughout the talk, and allows me to be more myself on stage.
Paragraph: 
Paragraph: 
When writing on a blog post, on the other hand, a �table of contents� approach is actually very useful. It helps me keep my readers engaged if I orient them at the start around what�s to come further down, and allows them to skip certain sections if they need to - a win for your readers!
Beyond that, it�s good to start your article with a good punch. I think of it like this: technical articles can get quite complex, so if my article has a slow start, it�s unlikely my readers will be invested until the end.
Paragraph: 
Part of OfferZen�s process, in fact, in writing an article, is to write the �sanity check� (the intro paragraph that defines the article), and make that the first thing your audience reads. It gives them an idea of what I�m going to tell them and why they should care, and acts as the second �hook� for their attention (where my title would be the first).
Paragraph: 
But don�t get too caught up in the technicalities of what you are trying to write about. If I�m going to write about something technical, I would explain it with a concrete anecdote.

Paragraph: 
If for some reason my audience already knows the explanation behind a technical point, they can skim through the explanation. If they don�t know the details, the concrete anecdote usually allows my audience to stay grounded without getting too lost in the generality of the technical claim being made.
Paragraph: My hacks here are:
Get your readers excited about your article with a good punch in the beginning. Not doing so could lead to them losing interest in the article due to its techy nature.
Explain technical points with concrete anecdotes. This helps to ground your reader and gives them a functional understanding of your point without getting too general.
H2: Tip 3: Tell a story
Paragraph: 
An important first step when first approaching any piece of media is to ask: What story am I trying to tell? How am I going to structure my media so that it leaves my audience with the message I was trying to convey? This is where coherency comes in. It asks you to create a story that flows easily from one page (or slide) to the next.
Paragraph: Giving a presentation
Paragraph: 
I like to tell a story to my audience. I�ve found that a good story keeps people listening. In my experience, the best way to make a good story is to stretch it from your first word to your last. This feeds in to the �edutainment� factor of your technical talk. Try to come up with an interesting story, and your audience will easily follow whatever technical things you include.
Paragraph: 
In my talks, I usually set the story of my talk around the visuals of my slide deck, and then around the content of my speech. It�s easier to start with the visuals, as these give the most visceral feel for how your presentation flows and feels.
Paragraph: 
To do this, I construct a slide deck with the overall story (this usually flows quite naturally) and follow this up with a round of reviews that focus on making my slide deck more impactful. This involves:
Finding the slides that have the most impact or most important information
Focusing on those first
Breaking-down any highly technical slide into two or three simpler slides, that help explain the concept
Paragraph: 
What I end up saying follows naturally from the slide deck, since at each point all you have to do is essentially explain what you�ve put on your slide!
Paragraph: Writing a blog article
Paragraph: Here, the importance of coherency in a blog post is much the same as it is in a talk.�You�re trying to tell a story to you audience, and that story needs a structure. I find it difficult to read an article if it loses its coherency, and I quickly turn away from it if I feel like I�ve lost track.
This is especially true in technical articles, where at times it often feels inconsistently paced by suddenly jumping into technical content without any warning.
Paragraph: 
I�ve personally struggled with getting this right a lot in my writing. In talks, it�s easy to ask my audience where they�re feeling lost, and establish what I need to do to get them back up to speed. I don�t get that luxury in a blog post.
Paragraph: 
What really helped me was to define a clear set of guidelines for my blog posts on what I want to achieve.
Paragraph: Before starting, I ask myself:
How should structure my article?
What context do I need before diving into the technical aspects of my article?
Paragraph: 
I like to structure my articles to have a �hook� paragraph, and then use the next two or three paragraphs to give some context to the technical aspects I want to talk about. More complex structures may emerge naturally from this process - such as specific sections or topics - but those end up helping add a smoother �flow� to the article.
H2: Tip 4: Make your information relatable
Paragraph: Giving a presentation
Paragraph: 
When presenting, it�s important to relate to your audience. If you want to deliver an effective presentation, you need to use language that they understand. When presenting a topic that your audience does not know much about, but that they are interested in, ask yourself: How can I bring my audience from a state of knowing very little about my topic, to (at the very least) being conversational on it?
Paragraph: 
I recently gave a talk about�my self-driving car�at the�DevelopersUserGroup�meetup. Seeing as this was a software developer group, I tried to incorporate some of the code I used in order to develop my self-driving car. I expected my audience to have some mathematical background, and be able to follow through some of the more technical points of my talk - as expected, they did.
Paragraph: 
In another talk on the same topic, this time to the public, I removed all slides that contained a hint of technicality or code, and instead tried to focus on the �cool� aspect of the self-driving car, and why they should find this piece of tech theory so interesting.
Paragraph: 
Had I given these talks the other way around, the developers would have been bored, and the public would have found it too difficult - and I�d end up losing both!
Paragraph: 
A good tip here is to use a concrete, everyday example to explain a complicated topic. In the case of my self-driving car, I first posed the question to my audience: How do we drive cars? The audience is welcome to answer, but then I ask another question: Can we drive blindfolded, or without access to the steering wheel? This introduced the crux of my article, that �driving� needs a feedback loop in order to get visual information and act upon it (if you�re intrigued, you can�read the full article here!)
Paragraph: 
My audience was able to engage with the questions I had to ask myself, and came to this conclusion on their own - meaning they�re now an active part of the presentation!
Paragraph: Writing a blog article
Paragraph: 
Similarly, when writing a blog post, you need to write in the language of your target audience.
Paragraph: As with giving talks, I like to explain complex technical topics using concrete anecdotes. In blogs, I try to make this as visual as possible - for example, I�ll explain neural networks by getting my readers to think about the complex structures of the brain, and then try to explain each aspect in so far as the anecdote can go, before returning to the more technical aspects of a neural network.
Paragraph: This can give my readers a way to ground themselves in reality, while also giving them a way to�visualise�what might be going on in a neural network.
Paragraph: 
If you follow these four tips, and try put yourself in your audience�s shoes, you�ll become a communcation expert. These may seem simple, but the pay-out of sticking to them has been immense for me - so I�m sure it�ll do the same for you!
H2: Latest Posts
15 Sep 2019
H3: How to Develop a Self-Driving Car in Under a Week.
Jason Webster

15 Sep 2019
H3: 4 Tips For Communicating Technical Ideas to a Non-tech Audience
Jason Webster

15 Sep 2019
H3: How Playing Games Inspires My Software Development.
Jacob Clarkson

H2: Lauch your career today 
and start doing Amazing Things
https://explore-datascience.net/home/blog_single/1
H3: How to Develop a Self-Driving Car in Under a Week
15 Sep 2019
Paragraph: Jason Webster
Paragraph: 
Self-driving cars are a major topic of interest in automobile research, because they�re safer and more fuel-efficient. As a machine-learning hobbyist intrigued by self-driving cars, I�ve always wanted to build one myself in a simulated environment. By using the power and accessibility of deep-learning, I achieved this in under a week. In this article, I�ll demonstrate the value of deep-learning by explaining how I did it and how others can reproduce this too.

Paragraph: 
My goal
Growing-up, I used to love driving-games. Getting home from school and racing against my brother in Gran Turismo, or chasing after cars in Need for Speed, used to be the order of the day. But I had always wondered how the game�s AI acted the way it did, how it produced human-like opponents. Now that I�m older, I know that the AI in those games would have used�path following algorithms�and�state control�to simulate human-like behaviour.
Although it�s a great solution in a simulated world, it rapidly falls apart in the real world where there are no states, no predetermined paths, and no room for error. We have to act on what we see� I was intrigued, and gave myself this task:�build a self-driving car in a game environment, where the only information it has access to is what it can see.

H2: My goal
Paragraph: 
The constraints
Due to what this task required me to do, and the limited resources I had at the time, I had to set some reasonable constraints. These included:

Time: I mostly considered myself a machine-learning�hobbyist, and�not a professional, and at the time I was also busy with my Masters. Thus, I had to put a limit on the time I spent on this project. I chose two weeks, but ended-up only needing one.
Budget: I only had a 2GB graphics card at my disposable. As I knew I would be using deep learning for this problem, my GPU memory was a relevant concern as deep learning typically requires a large amount of expensive, heavy-duty memory.
Performance: Given my time constraints, I knew I wouldn�t be able to make a groundbreaking algorithm. As such, I limited my performance goal to: if I could build a model that could drive reasonably well with little-to-no human input, it would be a success.


H2: The constraints
Time: I mostly considered myself a machine-learning�hobbyist, and�not a professional, and at the time I was also busy with my Masters. Thus, I had to put a limit on the time I spent on this project. I chose two weeks, but ended-up only needing one.
Budget: I only had a 2GB graphics card at my disposable. As I knew I would be using deep learning for this problem, my GPU memory was a relevant concern as deep learning typically requires a large amount of expensive, heavy-duty memory.
Performance: Given my time constraints, I knew I wouldn�t be able to make a groundbreaking algorithm. As such, I limited my performance goal to: if I could build a model that could drive reasonably well with little-to-no human input, it would be a success.
Paragraph: 
Figuring out how to go about it
I found a few useful YouTube videos on the topic from�Siraj Raval�and�SethBling, as well as a�very informative article by sentdex. Having looked at these, I had a better idea of what I needed to:

Choose a model�small enough to be able to fit on my 2GB GPU with a game running in the background, but also accurate enough to be able to make reasonable predictions.
Choose a game �to act as the simulated environment.
Record myself playing a game, monitoring my keystrokes as I do so in order to set up a supervised learning problem.
Use this data to train my model, so that it could make predictions.
Use these predictions to generate keystrokes in the game, so that the model could control the car.

With those steps laid-out, I could buckle-up and get going.

H2: Figuring out how to go about it
Choose a model�small enough to be able to fit on my 2GB GPU with a game running in the background, but also accurate enough to be able to make reasonable predictions.
Choose a game �to act as the simulated environment.
Record myself playing a game, monitoring my keystrokes as I do so in order to set up a supervised learning problem.
Use this data to train my model, so that it could make predictions.
Use these predictions to generate keystrokes in the game, so that the model could control the car.

Choose a game �to act as the simulated environment.
Record myself playing a game, monitoring my keystrokes as I do so in order to set up a supervised learning problem.
Use this data to train my model, so that it could make predictions.
Use these predictions to generate keystrokes in the game, so that the model could control the car.

Record myself playing a game, monitoring my keystrokes as I do so in order to set up a supervised learning problem.
Use this data to train my model, so that it could make predictions.
Use these predictions to generate keystrokes in the game, so that the model could control the car.

Use this data to train my model, so that it could make predictions.
Use these predictions to generate keystrokes in the game, so that the model could control the car.

Use these predictions to generate keystrokes in the game, so that the model could control the car.

H2: Step 1: Choosing a model
Paragraph: 
Our problem is essentially an image recognition problem, that is: given the current visual information from our game, which direction should we go in? From my experience, I knew that a convolutional neural network was likely the best approach for this case, as they form the backbone of state of the art image recognition models. Given my restraints, I knew I needed a model that was small and easy to compute. I also wanted to make a prediction based off of only the single frame displayed on the screen, as using more than one frame would start taxing my GPU memory budget.
Paragraph: 
Previous models that have worked extremely well in image recognition tasks include�VGG16,�Inception, and�ResNet50. Given that these models were built to classify millions of images into 1000 categories, they tend to be very large - anywhere between 20 to 150 million parameters. These models were too big and couldn�t make the cut.
Paragraph: 
Instead, I decided to build a custom neural net based off the VGG16 architecture, which makes use of a number of blocks (a group of multiple layers) with max-pooling and dropout layers between consecutive blocks. Since I wasn�t doing large-scale image recognition, I could adapt the architecture and significantly drop the number of parameters used in-model without significant loss of accuracy.
Paragraph: 
The architecture I settled on building was a sequential model, with each layer connected to the previous layer as follows:
A convolutional layer with a kernel size of 3x3, a depth of 32 channels, and a stride of two pixels, activated by a ReLU function.
H2: Latest Posts
15 Sep 2019
H3: How to Develop a Self-Driving Car in Under a Week.
Jason Webster

15 Sep 2019
H3: 4 Tips For Communicating Technical Ideas to a Non-tech Audience
Jason Webster

15 Sep 2019
H3: How Playing Games Inspires My Software Development.
Jacob Clarkson

H2: Lauch your career today 
and start doing Amazing Things
